// Copyright (c) 2010-2017 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of YAS(https://github.com/niXman/yas) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// This wraps the tests performed in tests/base/main.cpp to use BOOST_AUTO_TEST,
// specifically to be used as tests of a larger host project.

#define TEST_NAME "ext/yas"

#include <cassert>
#include <cstdio>
#include <fstream>
#include <functional>
#include <iostream>
#include <limits.h>
#include <map>

#include "util/testing.h"
#include "yas/binary_iarchive.hpp"
#include "yas/binary_oarchive.hpp"
#include "yas/detail/tools/cast.hpp"
#include "yas/file_streams.hpp"
#include "yas/mem_streams.hpp"
#include "yas/std_types.hpp"
#include "yas/text_iarchive.hpp"
#include "yas/text_oarchive.hpp"
#include "yas/tools/hexdumper.hpp"

#define YAS_SERIALIZE_BOOST_TYPES true

#ifdef YAS_SERIALIZE_BOOST_TYPES
#include "yas/boost_types.hpp"
#endif // YAS_SERIALIZE_BOOST_TYPES

#include "all_tests.hpp"

template <typename OA, typename IA>
struct ArchiveTraits {
  typedef OA oarchive_type;
  typedef IA iarchive_type;

  struct oarchive {
    oarchive() : oa{} {}

    virtual ~oarchive() {}

    oarchive_type* operator->() { return oa.get(); }

    template <typename T>
    oarchive_type& operator&(const T& v) {
      return (*(oa)&v);
    }

    oarchive_type& serialize() { return *oa; }

    template <typename Head, typename... Tail>
    oarchive_type& serialize(const Head& head, const Tail&... tail) {
      oa->operator&(head).serialize(tail...);

      return *oa;
    }

    template <typename... Ts>
    oarchive_type& operator()(const Ts&... ts) {
      oa->serialize(ts...);

      return *oa;
    }

    static constexpr bool is_little_endian() {
      return oarchive_type::is_little_endian();
    }
    static constexpr bool is_big_endian() {
      return oarchive_type::is_big_endian();
    }
    static constexpr yas::options host_endian() {
      return oarchive_type::host_endian();
    }
    std::size_t size() const { return stream.get_intrusive_buffer().size; }

    void dump(std::ostream& os = std::cout) {
      const yas::intrusive_buffer buf = stream.get_intrusive_buffer();
      os << yas::hex_dump(buf.data, buf.size) << std::endl;
    }

    bool compare(const void* ptr, std::uint32_t size) const {
      const yas::intrusive_buffer buf = stream.get_intrusive_buffer();
      return size == buf.size ? (0 == std::memcmp(buf.data, ptr, size)) : false;
    }

    typename oarchive_type::stream_type stream;
    std::unique_ptr<oarchive_type> oa;
  };

  static void ocreate(oarchive& oa, const char* archive_type) {
    ((void)archive_type);
    oa.oa.reset(new oarchive_type(oa.stream));
  }

  struct iarchive {
    iarchive() : stream{}, ia{} {}

    virtual ~iarchive() {}

    iarchive_type* operator->() { return ia.get(); }

    template <typename T>
    iarchive_type& operator&(T&& v) {
      return (*(ia)&std::forward<T>(v));
    }

    iarchive_type& serialize() { return *ia; }

    template <typename Head, typename... Tail>
    iarchive_type& serialize(Head&& head, Tail&&... tail) {
      ia->operator&(head).serialize(tail...);

      return *ia;
    }

    template <typename... Ts>
    iarchive_type& operator()(Ts&&... ts) {
      return ia->serialize(ts...);
      return *ia;
    }

    bool is_little_endian() { return ia->is_little_endian(); }
    bool is_big_endian() { return ia->is_big_endian(); }
    static constexpr yas::options host_endian() {
      return iarchive_type::host_endian();
    }
    std::size_t size() const { return stream->get_intrusive_buffer().size; }

    void dump(std::ostream& os = std::cout) {
      const yas::intrusive_buffer buf = stream->get_intrusive_buffer();
      os << yas::hex_dump(buf.data, buf.size) << std::endl;
    }

    bool compare(const void* ptr, std::uint32_t size) const {
      const yas::intrusive_buffer buf = stream->get_intrusive_buffer();
      return size == buf.size ? (0 == std::memcmp(buf.data, ptr, size)) : false;
    }

    std::unique_ptr<typename iarchive_type::stream_type> stream;
    std::unique_ptr<iarchive_type> ia;
  };

  static void icreate(iarchive& ia, oarchive& oa, const char* archive_type) {
    ((void)archive_type);
    ia.stream.reset(new typename iarchive_type::stream_type(
        oa.stream.get_intrusive_buffer()));
    ia.ia.reset(new iarchive_type(*(ia.stream)));
  }
};

#define YAS_TEST_BINARY(TESTNAME)                                             \
  { \
    typedef yas::binary_oarchive<yas::mem_ostream> OA;                   \
    typedef yas::binary_iarchive<yas::mem_istream> IA;                   \
    typedef ArchiveTraits<OA, IA> TestTraits;                            \
    const bool test_success = TESTNAME<TestTraits>(std::cerr, "binary"); \
    BOOST_CHECK(test_success);\
  }

#define YAS_TEST_TEXT(TESTNAME) \
  { \
    typedef yas::text_oarchive<yas::mem_ostream, yas::text> OA;                   \
    typedef yas::text_iarchive<yas::mem_istream, yas::text> IA;                   \
    typedef ArchiveTraits<OA, IA> TestTraits;                            \
    const bool test_success = TESTNAME<TestTraits>(std::cerr, "text"); \
    BOOST_CHECK(test_success);\
  }

#define YAS_TESTS(TESTNAME) YAS_TEST_TEXT(TESTNAME) YAS_TEST_BINARY(TESTNAME)

// Internal serialization sanity checks.
BOOST_AUTO_TEST_CASE(Header) { YAS_TESTS(header_test) }
BOOST_AUTO_TEST_CASE(Endian) { YAS_TEST_BINARY(endian_test) }

// Serialization of yas data.
BOOST_AUTO_TEST_CASE(Version) { YAS_TESTS(version_test) }
BOOST_AUTO_TEST_CASE(BaseObject) { YAS_TESTS(base_object_test) }
BOOST_AUTO_TEST_CASE(Buffer) { YAS_TEST_BINARY(buffer_test) }
BOOST_AUTO_TEST_CASE(YasObject) { YAS_TESTS(yas_object_test) }

// POD, enums and arrays of POD.
BOOST_AUTO_TEST_CASE(Fundamental) { YAS_TESTS(fundamental_test) }
BOOST_AUTO_TEST_CASE(Enum) { YAS_TESTS(enum_test) }
BOOST_AUTO_TEST_CASE(CStyleArray) { YAS_TESTS(auto_array_test) }

// All STL types tests that YAS can serialize.
BOOST_AUTO_TEST_CASE(Array) { YAS_TESTS(array_test) }
BOOST_AUTO_TEST_CASE(Bitset) { YAS_TESTS(bitset_test) }
BOOST_AUTO_TEST_CASE(Chrono) { YAS_TESTS(chrono_test) }
BOOST_AUTO_TEST_CASE(Complex) { YAS_TESTS(complex_test) }
BOOST_AUTO_TEST_CASE(String) { YAS_TESTS(string_test) }
BOOST_AUTO_TEST_CASE(Wstring) { YAS_TESTS(wstring_test) }
BOOST_AUTO_TEST_CASE(Pair) { YAS_TESTS(pair_test) }
BOOST_AUTO_TEST_CASE(Tuple) { YAS_TESTS(tuple_test) }
BOOST_AUTO_TEST_CASE(Vector) { YAS_TESTS(vector_test) }
BOOST_AUTO_TEST_CASE(List) { YAS_TESTS(list_test) }
BOOST_AUTO_TEST_CASE(ForwardList) { YAS_TESTS(forward_list_test) }
BOOST_AUTO_TEST_CASE(Map) { YAS_TESTS(map_test) }
BOOST_AUTO_TEST_CASE(Deque) { YAS_TESTS(deque_test) }
BOOST_AUTO_TEST_CASE(Set) { YAS_TESTS(set_test) }
BOOST_AUTO_TEST_CASE(Multimap) { YAS_TESTS(multimap_test) }
BOOST_AUTO_TEST_CASE(Multiset) { YAS_TESTS(multiset_test) }
BOOST_AUTO_TEST_CASE(Unordered_map) { YAS_TESTS(unordered_map_test) }
BOOST_AUTO_TEST_CASE(Unordered_set) { YAS_TESTS(unordered_set_test) }
BOOST_AUTO_TEST_CASE(Unordered_multimap) { YAS_TESTS(unordered_multimap_test) }
BOOST_AUTO_TEST_CASE(Unordered_multiset) { YAS_TESTS(unordered_multiset_test) }
BOOST_AUTO_TEST_CASE(Optional) { YAS_TESTS(optional_test) }

// Serialization tests for user-defined types.
BOOST_AUTO_TEST_CASE(OneFunction) { YAS_TESTS(one_function_test) }
BOOST_AUTO_TEST_CASE(SplitFunctions) { YAS_TESTS(split_functions_test) }
BOOST_AUTO_TEST_CASE(OneMethod) { YAS_TESTS(one_method_test) }
BOOST_AUTO_TEST_CASE(SplitMethods) { YAS_TESTS(split_methods_test) }
BOOST_AUTO_TEST_CASE(Methods) { YAS_TESTS(serialization_methods_test) }

// Optional serialization of boost types.
#if defined(YAS_SERIALIZE_BOOST_TYPES)
BOOST_AUTO_TEST_CASE(BoostString) { YAS_TESTS(boost_cont_string_test) }
BOOST_AUTO_TEST_CASE(BoostVector) { YAS_TESTS(boost_cont_vector_test) }
BOOST_AUTO_TEST_CASE(BoostStaticVector) { YAS_TESTS(boost_cont_static_vector_test) }
BOOST_AUTO_TEST_CASE(BoostStableVector) { YAS_TESTS(boost_cont_stable_vector_test) }
BOOST_AUTO_TEST_CASE(BoostList) { YAS_TESTS(boost_cont_list_test) }
BOOST_AUTO_TEST_CASE(BoostSlist) { YAS_TESTS(boost_cont_slist_test) }
BOOST_AUTO_TEST_CASE(BoostMap) { YAS_TESTS(boost_cont_map_test) }
BOOST_AUTO_TEST_CASE(BoostMultimap) { YAS_TESTS(boost_cont_multimap_test) }
BOOST_AUTO_TEST_CASE(BoostSet) { YAS_TESTS(boost_cont_set_test) }
BOOST_AUTO_TEST_CASE(BoostMultiset) { YAS_TESTS(boost_cont_multiset_test) }
BOOST_AUTO_TEST_CASE(BoostFlatMap) { YAS_TESTS(boost_cont_flat_map_test) }
BOOST_AUTO_TEST_CASE(BoostFlatMultimap) { YAS_TESTS(boost_cont_flat_multimap_test) }
BOOST_AUTO_TEST_CASE(BoostFlatSet) { YAS_TESTS(boost_cont_flat_set_test) }
BOOST_AUTO_TEST_CASE(BoostFlatMultiset) { YAS_TESTS(boost_cont_flat_multiset_test) }
BOOST_AUTO_TEST_CASE(BoostDeque) { YAS_TESTS(boost_cont_deque_test) }
BOOST_AUTO_TEST_CASE(BoostTuple) { YAS_TESTS(boost_tuple_test) }
#endif // defined(YAS_SERIALIZE_BOOST_TYPES)
